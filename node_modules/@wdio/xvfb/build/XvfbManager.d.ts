import type { Capabilities } from '@wdio/types';
export interface XvfbOptions {
    /**
     * Force Xvfb to run even on non-Linux systems (for testing)
     */
    force?: boolean;
    /**
     * Override package manager detection (for testing)
     */
    packageManager?: string;
    /**
     * Skip xvfb-run availability check and force installation (for testing)
     */
    forceInstall?: boolean;
    /**
     * Enable automatic installation of Xvfb packages if `xvfb-run` is missing (default: false)
     */
    autoInstall?: boolean;
    /**
     * Number of retry attempts for xvfb process failures (default: 3)
     */
    xvfbMaxRetries?: number;
    /**
     * Base delay between retries in milliseconds (default: 1000)
     * Progressive delay will be: baseDelay * attemptNumber
     */
    xvfbRetryDelay?: number;
}
export declare class XvfbManager {
    private force;
    private packageManagerOverride?;
    private forceInstall;
    private autoInstall;
    private maxRetries;
    private retryDelay;
    private log;
    constructor(options?: XvfbOptions);
    /**
     * Check if Xvfb should run on this system
     */
    shouldRun(capabilities?: Capabilities.ResolvedTestrunnerCapabilities): boolean;
    /**
     * Initialize xvfb-run for use
     * @returns Promise<boolean> - true if xvfb-run is ready, false if not needed
     */
    init(capabilities?: Capabilities.ResolvedTestrunnerCapabilities): Promise<boolean>;
    /**
     * Ensure xvfb-run is available, installing if necessary
     */
    private ensureXvfbRunAvailable;
    /**
     * Detect if headless mode is enabled in Chrome/Chromium capabilities
     */
    private detectHeadlessMode;
    /**
     * Check if the capabilities object is a single capability (not multiremote)
     */
    private isSingleCapability;
    /**
     * Check if the capabilities object is multiremote
     */
    private isMultiRemoteCapability;
    /**
     * Extract capabilities from browser config (handles both nested and direct formats)
     */
    private extractCapabilitiesFromBrowserConfig;
    /**
     * Check a single capability object for headless flags
     */
    private checkCapabilityForHeadless;
    /**
     * Check if browser options contain headless flags
     */
    private hasHeadlessFlag;
    protected detectPackageManager(): Promise<string>;
    private installXvfbPackages;
    /**
     * Execute a command with retry logic for xvfb failures
     */
    executeWithRetry<T>(commandFn: () => Promise<T>, context?: string): Promise<T>;
    /**
     * Check if an error is related to xvfb failures
     */
    private isXvfbError;
}
//# sourceMappingURL=XvfbManager.d.ts.map